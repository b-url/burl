// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package api_test

import (
	"context"
	"database/sql"
	"github.com/b-url/burl/cmd/server/bookmark"
	"sync"
)

// Ensure, that RepositoryMock does implement bookmark.Repository.
// If this is not the case, regenerate this file with moq.
var _ bookmark.Repository = &RepositoryMock{}

// RepositoryMock is a mock implementation of bookmark.Repository.
//
//	func TestSomethingThatUsesRepository(t *testing.T) {
//
//		// make and configure a mocked bookmark.Repository
//		mockedRepository := &RepositoryMock{
//			CreateBookmarkFunc: func(ctx context.Context, tx *sql.Tx, bookmarkMoqParam *bookmark.Bookmark) (*bookmark.Bookmark, error) {
//				panic("mock out the CreateBookmark method")
//			},
//			TransactionallyFunc: func(ctx context.Context, f func(tx *sql.Tx) error) error {
//				panic("mock out the Transactionally method")
//			},
//		}
//
//		// use mockedRepository in code that requires bookmark.Repository
//		// and then make assertions.
//
//	}
type RepositoryMock struct {
	// CreateBookmarkFunc mocks the CreateBookmark method.
	CreateBookmarkFunc func(ctx context.Context, tx *sql.Tx, bookmarkMoqParam *bookmark.Bookmark) (*bookmark.Bookmark, error)

	// TransactionallyFunc mocks the Transactionally method.
	TransactionallyFunc func(ctx context.Context, f func(tx *sql.Tx) error) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateBookmark holds details about calls to the CreateBookmark method.
		CreateBookmark []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx *sql.Tx
			// BookmarkMoqParam is the bookmarkMoqParam argument value.
			BookmarkMoqParam *bookmark.Bookmark
		}
		// Transactionally holds details about calls to the Transactionally method.
		Transactionally []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// F is the f argument value.
			F func(tx *sql.Tx) error
		}
	}
	lockCreateBookmark  sync.RWMutex
	lockTransactionally sync.RWMutex
}

// CreateBookmark calls CreateBookmarkFunc.
func (mock *RepositoryMock) CreateBookmark(ctx context.Context, tx *sql.Tx, bookmarkMoqParam *bookmark.Bookmark) (*bookmark.Bookmark, error) {
	callInfo := struct {
		Ctx              context.Context
		Tx               *sql.Tx
		BookmarkMoqParam *bookmark.Bookmark
	}{
		Ctx:              ctx,
		Tx:               tx,
		BookmarkMoqParam: bookmarkMoqParam,
	}
	mock.lockCreateBookmark.Lock()
	mock.calls.CreateBookmark = append(mock.calls.CreateBookmark, callInfo)
	mock.lockCreateBookmark.Unlock()
	if mock.CreateBookmarkFunc == nil {
		var (
			bookmarkOut *bookmark.Bookmark
			errOut      error
		)
		return bookmarkOut, errOut
	}
	return mock.CreateBookmarkFunc(ctx, tx, bookmarkMoqParam)
}

// CreateBookmarkCalls gets all the calls that were made to CreateBookmark.
// Check the length with:
//
//	len(mockedRepository.CreateBookmarkCalls())
func (mock *RepositoryMock) CreateBookmarkCalls() []struct {
	Ctx              context.Context
	Tx               *sql.Tx
	BookmarkMoqParam *bookmark.Bookmark
} {
	var calls []struct {
		Ctx              context.Context
		Tx               *sql.Tx
		BookmarkMoqParam *bookmark.Bookmark
	}
	mock.lockCreateBookmark.RLock()
	calls = mock.calls.CreateBookmark
	mock.lockCreateBookmark.RUnlock()
	return calls
}

// Transactionally calls TransactionallyFunc.
func (mock *RepositoryMock) Transactionally(ctx context.Context, f func(tx *sql.Tx) error) error {
	callInfo := struct {
		Ctx context.Context
		F   func(tx *sql.Tx) error
	}{
		Ctx: ctx,
		F:   f,
	}
	mock.lockTransactionally.Lock()
	mock.calls.Transactionally = append(mock.calls.Transactionally, callInfo)
	mock.lockTransactionally.Unlock()
	if mock.TransactionallyFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TransactionallyFunc(ctx, f)
}

// TransactionallyCalls gets all the calls that were made to Transactionally.
// Check the length with:
//
//	len(mockedRepository.TransactionallyCalls())
func (mock *RepositoryMock) TransactionallyCalls() []struct {
	Ctx context.Context
	F   func(tx *sql.Tx) error
} {
	var calls []struct {
		Ctx context.Context
		F   func(tx *sql.Tx) error
	}
	mock.lockTransactionally.RLock()
	calls = mock.calls.Transactionally
	mock.lockTransactionally.RUnlock()
	return calls
}
